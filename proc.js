// Generated by CoffeeScript 1.3.3
(function() {
  var PROCSTAT_FORMAT, addChild, fs, nc, numeric, onUpdate, parseProcStat, proc, procCache, returnUpdate, updateCache, updateProc, updateProcErr, updating, _;

  fs = require('fs');

  _ = require('underscore');

  PROCSTAT_FORMAT = "pid comm state ppid pgrp session tty_nr tpgid flags minflt cminflt majflt cmajflt utime stime cutime cstime priority nice num_threads itrealvalue starttime vsize lu rss rsslim startcode endcode startstack kstkesp kstkeip signal blocked sigignore sigcatch wchan nswap cnswap exit_signal processor rt_priority policy delayacct_blkio_ticks guest_time cguest_time".split(" ");

  procCache = null;

  updating = false;

  onUpdate = [];

  returnUpdate = function(err, result) {
    var cb, _i, _len;
    updating = false;
    for (_i = 0, _len = onUpdate.length; _i < _len; _i++) {
      cb = onUpdate[_i];
      cb(err, result);
    }
    onUpdate = [];
    if (!err) {
      return process.nextTick(function() {
        return procCache = null;
      });
    }
  };

  numeric = /^\d+$/;

  updateCache = function(cb) {
    if (updating) {
      return onUpdate.push(cb);
    }
    if (procCache) {
      return cb(null, procCache);
    }
    updating = true;
    procCache = {};
    onUpdate.push(cb);
    return fs.readdir('/proc', function(err, files) {
      var count, done, file, updateProcErr, _fn, _i, _len;
      if (err) {
        return returnUpdate(err);
      }
      done = null;
      count = 0;
      updateProcErr = false;
      _fn = function(file) {
        if (file.match(numeric)) {
          count++;
          return process.nextTick(function() {
            return updateProc(file, done);
          });
        }
      };
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _fn(file);
      }
      return done = _.after(count, function() {
        if (updateProcErr) {
          return returnUpdate(updateProcErr);
        }
        return returnUpdate(null, procCache);
      });
    });
  };

  nc = 0;

  updateProcErr = false;

  updateProc = function(pid, cb) {
    return fs.readFile("/proc/" + pid + "/stat", 'utf8', function(err, contents) {
      var procStat;
      if (err) {
        return cb(updateProcErr = err);
      }
      procCache[pid] || (procCache[pid] = {});
      procStat = parseProcStat(contents);
      _.extend(procCache[pid], procStat);
      addChild(procStat.ppid, pid);
      return process.nextTick(function() {
        return cb();
      });
    });
  };

  addChild = function(ppid, pid) {
    var _base;
    procCache[pid].parent = ppid;
    procCache[ppid] || (procCache[ppid] = {});
    (_base = procCache[ppid]).children || (_base.children = []);
    return procCache[ppid].children.push(procCache[pid]);
  };

  parseProcStat = function(procStat) {
    var i, name, ret, stat, stats, _i, _len;
    ret = {};
    stats = procStat.trim().split(" ");
    for (i = _i = 0, _len = stats.length; _i < _len; i = ++_i) {
      stat = stats[i];
      name = PROCSTAT_FORMAT[i];
      if (name) {
        ret[name] = stat;
      } else {
        console.warn("WARNING: don't know what to do with field " + i);
      }
    }
    return ret;
  };

  proc = function(pid, cb) {
    var _ref;
    if (cb == null) {
      _ref = [null, pid], pid = _ref[0], cb = _ref[1];
    }
    return updateCache(function(err, pcache) {
      if (err) {
        return cb(err);
      } else {
        return cb(null, pid ? pcache[pid] : pcache);
      }
    });
  };

  module.exports = proc;

}).call(this);
